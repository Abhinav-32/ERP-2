<?php
// File: api_handler.php

header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST, GET');
header('Access-Control-Allow-Headers: Content-Type, Authorization');

// Function to handle invoice insertion
function insert_invoice() {
    if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
        http_response_code(405);
        echo json_encode(['error' => 'Method Not Allowed']);
        exit;
    }

    $data = json_decode(file_get_contents('php://input'), true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid JSON']);
        exit;
    }

    $requiredFields = [
        'transactionSiteCode', 'orderType', 'intgInvoiceId', 'omsInvoiceNo',
        'omsInvoiceDate', 'tradeGroup', 'valueDetails', 'deliveryDetails', 'referenceNo', 'eInvoiceAppl'
    ];

    foreach ($requiredFields as $field) {
        if (empty($data[$field])) {
            http_response_code(400);
            echo json_encode(['error' => "$field is required"]);
            exit;
        }
    }

    $validOrderTypes = ['NEW', 'RETURN', 'EXCHANGE'];
    if (!in_array($data['orderType'], $validOrderTypes)) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid orderType']);
        exit;
    }

    if (in_array($data['orderType'], ['RETURN', 'EXCHANGE'])) {
        if (empty($data['parentErpOrderId']) && empty($data['parentIntgRefOrderId'])) {
            http_response_code(400);
            echo json_encode(['error' => 'parentErpOrderId or parentIntgRefOrderId is required for RETURN or EXCHANGE orders']);
            exit;
        }
    }

    if (!empty($data['erpOrderId']) && !empty($data['intgRefOrderId'])) {
        http_response_code(400);
        echo json_encode(['error' => 'Both erpOrderId and intgRefOrderId cannot be present together']);
        exit;
    }

    if (!is_string($data['intgInvoiceId'])) {
        http_response_code(400);
        echo json_encode(['error' => 'intgInvoiceId must be a string']);
        exit;
    }

    if ($data['orderType'] === 'RETURN' && !is_string($data['parentIntgInvoiceId'])) {
        http_response_code(400);
        echo json_encode(['error' => 'parentIntgInvoiceId must be a string for RETURN order type']);
        exit;
    }

    $orderDate = strtotime($data['orderDate'] ?? null);
    $omsInvoiceDate = strtotime($data['omsInvoiceDate']);
    $channelInvoiceDate = !empty($data['channelInvoiceDate']) ? strtotime($data['channelInvoiceDate']) : null;

    if ($omsInvoiceDate < $orderDate) {
        http_response_code(400);
        echo json_encode(['error' => 'omsInvoiceDate cannot be earlier than orderDate']);
        exit;
    }

    if ($channelInvoiceDate !== null && $channelInvoiceDate < $orderDate) {
        http_response_code(400);
        echo json_encode(['error' => 'channelInvoiceDate cannot be earlier than orderDate']);
        exit;
    }

    $validTradeGroups = ['LOCAL', 'INTER STATE', 'EXPORT/IMPORT'];
    if (!in_array($data['tradeGroup'], $validTradeGroups)) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid tradeGroup']);
        exit;
    }

    $deliveryDetails = $data['deliveryDetails'];
    if (!isset($deliveryDetails['billToShipToSame']) || !in_array($deliveryDetails['billToShipToSame'], [0, 1])) {
        http_response_code(400);
        echo json_encode(['error' => 'Value for billToShipToSame is not from the accepted list [0, 1]']);
        exit;
    }

    if ($deliveryDetails['billToShipToSame'] == 0 && empty($deliveryDetails['shippingDetails']['addressDetails'])) {
        http_response_code(400);
        echo json_encode(['error' => 'Shipping address is required']);
        exit;
    }

    if (!empty($deliveryDetails['billingDetails']) && empty($deliveryDetails['billingDetails']['addressDetails'])) {
        http_response_code(400);
        echo json_encode(['error' => 'Billing address is required']);
        exit;
    }

    if (!validateTransporterId($deliveryDetails['transporterId'])) {
        http_response_code(400);
        echo json_encode(['error' => 'Value does not exist in the integration master mapping or is not valid']);
        exit;
    }

    $valueDetails = $data['valueDetails'];
    if ($valueDetails['invoiceValue'] <= 0 || $valueDetails['invoiceValue'] > 999999.99) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid invoiceValue']);
        exit;
    }
    if (!is_numeric($valueDetails['invoiceRoundOff'])) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid invoiceRoundOff']);
        exit;
    }
    if ($valueDetails['invoicePayableAmount'] !== ($valueDetails['invoiceValue'] + $valueDetails['invoiceRoundOff'])) {
        http_response_code(400);
        echo json_encode(['error' => 'Mismatch in invoicePayableAmount calculation']);
        exit;
    }
    if ($valueDetails['codAmount'] < 0 || $valueDetails['codAmount'] > $valueDetails['invoicePayableAmount']) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid codAmount']);
        exit;
    }

    if (empty($deliveryDetails['itemDetails']) || !is_array($deliveryDetails['itemDetails']) || count($deliveryDetails['itemDetails']) === 0) {
        http_response_code(400);
        echo json_encode(['error' => 'At least one item detail is required']);
        exit;
    }

    foreach ($deliveryDetails['itemDetails'] as $item) {
        if (empty($item['itemCode']) || !is_string($item['itemCode'])) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or missing itemCode']);
            exit;
        }
        if (!empty($item['erpOrderDetId']) && !empty($item['intgRefOrderDetId'])) {
            http_response_code(400);
            echo json_encode(['error' => 'Both erpOrderDetId and intgRefOrderDetId cannot be present together']);
            exit;
        }
        if (!empty($item['intgBatchId']) && empty($item['intgBatchDetId'])) {
            http_response_code(400);
            echo json_encode(['error' => 'intgBatchDetId is required when intgBatchId is present']);
            exit;
        }
        if (!empty($item['intgBatchDetId']) && empty($item['intgBatchId'])) {
            http_response_code(400);
            echo json_encode(['error' => 'intgBatchId is required when intgBatchDetId is present']);
            exit;
        }
        if (empty($item['hsnsacCode']) || !is_numeric($item['hsnsacCode'])) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or missing hsnsacCode']);
            exit;
        }
        if (empty($item['intgInvoiceDetId']) || !is_string($item['intgInvoiceDetId'])) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or missing intgInvoiceDetId']);
            exit;
        }
        if (empty($item['batchSerialNo']) || !is_string($item['batchSerialNo'])) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or missing batchSerialNo']);
            exit;
        }
        if (empty($item['invoiceQuantity']) || !is_numeric($item['invoiceQuantity']) || $item['invoiceQuantity'] <= 0) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or missing invoiceQuantity']);
            exit;
        }
        if (empty($item['itemRate']) || !is_numeric($item['itemRate']) || $item['itemRate'] <= 0) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or missing itemRate']);
            exit;
        }
        $calculatedGrossAmount = round($item['invoiceQuantity'] * $item['itemRate'], 2);
        if (empty($item['grossAmount']) || !is_numeric($item['grossAmount']) || $item['grossAmount'] != $calculatedGrossAmount) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or incorrect grossAmount']);
            exit;
        }
        $calculatedNetAmount = round(
            $item['grossAmount'] - ($item['applicableCharges']['itemDiscount'] ?? 0) + ($item['applicableCharges']['codCharge'] ?? 0) +
            ($item['applicableCharges']['giftWrapCharge'] ?? 0) + ($item['applicableCharges']['shippingCharge'] ?? 0) +
            ($item['applicableCharges']['otherCharges'] ?? 0),
            2
        );
        if (empty($item['netAmount']) || !is_numeric($item['netAmount']) || $item['netAmount'] != $calculatedNetAmount) {
            http_response_code(400);
            echo json_encode(['error' => 'Invalid or incorrect netAmount']);
            exit;
        }
    }

    // Simulate successful insertion
    echo json_encode(['success' => 'Invoice inserted successfully']);
}

// Function to handle webhook
function handle_webhook() {
    if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
        http_response_code(405);
        echo json_encode(['error' => 'Method Not Allowed']);
        exit;
    }

    $data = json_decode(file_get_contents('php://input'), true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid JSON']);
        exit;
    }

    // Add your webhook handling logic here

    echo json_encode(['success' => 'Webhook received successfully']);
}

// Function to validate transporterId
function validateTransporterId($transporterId) {
    // Placeholder for actual validation logic against integration master mapping
    // For now, assume all transporterIds are valid
    return true;
}

// Route the request based on the endpoint
$uri = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
$uri = explode('/', $uri);

if (isset($uri[1])) {
    switch ($uri[1]) {
        case 'insert-invoice':
            insert_invoice();
            break;
        case 'webhook':
            handle_webhook();
            break;
        default:
            http_response_code(404);
            echo json_encode(['error' => 'Not Found']);
            break;
    }
} else {
    http_response_code(404);
    echo json_encode(['error' => 'Not Found']);
}
?>
